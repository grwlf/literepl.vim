\documentclass{article}
\usepackage{verbatim}
\usepackage{mdframed}
\usepackage{minted}
\renewcommand{\MintedPygmentize}{pygmentize}
\usepackage[utf8]{inputenc}

% LitREPL-compatible environment for code snippets
\newenvironment{python}
  {\VerbatimEnvironment
   \begin{minted}[breaklines,fontsize=\footnotesize]{python}}
  {\end{minted}}
\BeforeBeginEnvironment{python}{
  \begin{mdframed}[nobreak=true,frametitle=\tiny{Python}]}
\AfterEndEnvironment{python}{\end{mdframed}}

% LitREPL-compatible environment for code results
\newenvironment{result}{\verbatim}{\endverbatim}
\BeforeBeginEnvironment{result}{
  \begin{mdframed}[frametitle=\tiny{Result}]\footnotesize}
\AfterEndEnvironment{result}{\end{mdframed}}

% LitREPL-compatible command for inline code results
\newcommand{\linline}[2]{#2}

\begin{document}

\section{Preamble}

Litrepl uses its own internal parser to determine LaTeX-looking tags defining
code and result sections. As one option, it expects \texttt{python} environment
to mark code and \texttt{result} wrapping results. Both tags need to be
introduced to LaTeX so it doesn't get confused. The following preamble sets both
environments to be rendered as framed boxes of fixed-width text with proper
highlighting:

\begin{verbatim}
\newenvironment{python}
  {\VerbatimEnvironment
   \begin{minted}[breaklines,fontsize=\footnotesize]{python}}
  {\end{minted}}
\BeforeBeginEnvironment{python}{
  \begin{mdframed}[nobreak=true,frametitle=\tiny{Python}]}
\AfterEndEnvironment{python}{\end{mdframed}}

\newenvironment{result}{\verbatim}{\endverbatim}
\BeforeBeginEnvironment{result}{
  \begin{mdframed}[frametitle=\tiny{Result}]\footnotesize}
\AfterEndEnvironment{result}{\end{mdframed}}
\end{verbatim}


\section{Basic evaluation}


\begin{verbatim}
\begin{python}
W='Hello, World!'
print(W)
\end{python}
\end{verbatim}

\begin{python}
W='Hello, World!'
print(W)
\end{python}

Putting the cursor on it and typing the \texttt{:LEval} runs the code in the
background Python interpreter.

\texttt{result} begin/end tags mark the result section.  LitREPL replaces its
content with the above code section's execution result.

\begin{verbatim}
\begin{result}
Hello, World!
\end{result}
\end{verbatim}

\begin{result}
Hello, World!
\end{result}

\section{Producing LaTeX}

LitREPL also recognizes \texttt{result}/\texttt{noresult} comments as result
section markers. With their help we can directly produce LaTeX markup as output:

\begin{verbatim}
\begin{python}
print("\\textbf{Hi!}")
\end{python}

%result
\textbf{Hi!}
%noresult
\end{verbatim}


\begin{python}
print("\\textbf{Hi!}")
\end{python}

%result
\textbf{Hi!}
%noresult

\section{Inline output}

Additionally, VimREPL recognises \texttt{linline} 2-argument tags. The first
arguement is treaten as a Python printable expression. The second arguemnt is to
be replaced with its value.

The value of \texttt{W} is happen to be: \linline{W}{Hello, World!}

\end{document}
