\documentclass{article}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{mdframed}
\usepackage{minted}

\newenvironment{lcode}
  {\VerbatimEnvironment
   \begin{mdframed}
   \begin{minted}[breaklines, fontsize=\footnotesize]{python}}
  {\end{minted}
   \end{mdframed}}
\newenvironment{lresult}
  {\begin{mdframed}}
  {\end{mdframed}}
\newcommand{\linline}[2]{#2}

\graphicspath{ {./} }

\begin{document}

\section{Environment tags}

LitREPL treats specially named Latex environments as code and result sections.
It doesn't really evaluate \TeX\ commands so the tags should present in the source
file explicitly rather than be a result of other commands such as
\texttt{newcommand} or \texttt{newenvironment}.

\begin{verbatim}
\newenvironment{lcode}
  {\VerbatimEnvironment
   \begin{mdframed}
   \begin{minted}[breaklines, fontsize=\footnotesize]{python}}
  {\end{minted}
   \end{mdframed}}
\newenvironment{lresult}
  {\begin{mdframed}[leftline=false,rightline=false]}
  {\end{mdframed}}
\newcommand{\linplace}[2]{#2}
\end{verbatim}

\section{Executing code snippets}

Executable code is obtained from the content of the \texttt{lcode} environment.
Putting the cursor on this environment and typing the \texttt{:LitEval1} Vim
command sends the code to the Python interpreter persistently running in the
background.

%lignore
\begin{verbatim}
\begin{lcode}
W='Hello, world!'
print(W)
\end{lcode}
\end{verbatim}
%lnoignore

\begin{lcode}
W='Hello, my world!'
print(W)
\end{lcode}

\texttt{lresult} section next to the executable section is a result container.
When executed, LitREPL replaces its content with the executable code output.

%lignore
\begin{verbatim}
\begin{lresult}
PLACEHOLDER
\end{lresult}
\end{verbatim}
%lnoignore

\begin{lresult}
Hello, my world!
\end{lresult}

VimREPL also recognises commented \texttt{lresult} tags as a valid result
container. This we can generate custom parts of the document.

%lignore
\begin{lcode}
print('Hello, zzLitREPL.vim!')
\end{lcode}
\begin{verbatim}
%\begin{lresult}
PLACEHOLDER
%\end{lresult}
\end{verbatim}

%lnoignore

\begin{lcode}
print('Hello, LitREPL.vim!')
\end{lcode}

\begin{mdframed}
%\begin{lresult}
Hello, LitREPL.vim!
%\end{lresult}
\end{mdframed}

A special two-argument \texttt{linline} tag works both as an executable section
and as a result container. We expect it to be used to print the contents of
Python variables, so the VimREPL wraps the executable code with the additional
\texttt{print(...)} operator. On the Latex side, we define the tag to ignore its
first argument but pass the second one as-is.

%lignore
\begin{verbatim}
\begin{mdframed}\linline{W}{??}\end{mdframed}
\end{verbatim}
%lnoignore

\begin{mdframed}\linline{W}{Hello, world!}\end{mdframed}

\section{Mathplotlib plots and other graphics}

\begin{lcode}
import numpy as np
import matplotlib.pyplot as plt
X=np.array(range(10))
plt.plot(X, np.sin(X))
path='_img.png'
plt.savefig(path)
\end{lcode}

\includegraphics{\linline{path}{_img.png}}

\end{document}
